package application

import (
	"context"
	"fmt"
	"time"

	"go-factory-platform/services/compiler-builder-service/internal/domain"
)

// CompilerApplicationService implements the business logic for compilation
type CompilerApplicationService struct {
	fileSystemService domain.FileSystemService
	compilerService   domain.CompilerService
	projectService    domain.ProjectService
}

// NewCompilerApplicationService creates a new compiler application service
func NewCompilerApplicationService(
	fileSystemService domain.FileSystemService,
	compilerService domain.CompilerService,
	projectService domain.ProjectService,
) *CompilerApplicationService {
	return &CompilerApplicationService{
		fileSystemService: fileSystemService,
		compilerService:   compilerService,
		projectService:    projectService,
	}
}

// WriteFiles writes accumulated code files to the filesystem
func (s *CompilerApplicationService) WriteFiles(ctx context.Context, accumulator *domain.CodeAccumulator, outputPath string) error {
	fmt.Printf("Writing %d files to %s\n", len(accumulator.Files), outputPath)

	return s.fileSystemService.WriteFiles(ctx, accumulator, outputPath)
}

// CompileProject compiles a Go project
func (s *CompilerApplicationService) CompileProject(ctx context.Context, projectPath string) (*domain.CompilationResult, error) {
	fmt.Printf("Compiling project at %s\n", projectPath)

	return s.compilerService.CompileProject(ctx, projectPath)
}

// ValidateCode validates generated code files
func (s *CompilerApplicationService) ValidateCode(ctx context.Context, files []domain.GeneratedFile) (*domain.ValidationResult, error) {
	fmt.Printf("Validating %d files\n", len(files))

	return s.compilerService.ValidateCode(ctx, files)
}

// CreateProject creates a new Go project with the specified structure
func (s *CompilerApplicationService) CreateProject(ctx context.Context, structure *domain.ProjectStructure) error {
	fmt.Printf("Creating project at %s\n", structure.RootPath)

	return s.projectService.CreateProject(ctx, structure)
}

// BuildProject builds a Go project and outputs binary
func (s *CompilerApplicationService) BuildProject(ctx context.Context, projectPath, outputPath string) (*domain.CompilationResult, error) {
	fmt.Printf("Building project %s to %s\n", projectPath, outputPath)

	return s.compilerService.BuildProject(ctx, projectPath, outputPath)
}

// FormatCode formats Go code
func (s *CompilerApplicationService) FormatCode(ctx context.Context, content string) (string, error) {
	return s.compilerService.FormatCode(ctx, content)
}

// InitializeGoModule initializes a Go module
func (s *CompilerApplicationService) InitializeGoModule(ctx context.Context, projectPath, moduleName string) error {
	fmt.Printf("Initializing Go module %s at %s\n", moduleName, projectPath)

	return s.projectService.InitializeGoModule(ctx, projectPath, moduleName)
}

// CreateStandardProjectStructure creates a standard Go project structure
func (s *CompilerApplicationService) CreateStandardProjectStructure(ctx context.Context, rootPath, moduleName string) (*domain.ProjectStructure, error) {
	structure := &domain.ProjectStructure{
		RootPath:   rootPath,
		ModuleName: moduleName,
		GoVersion:  "1.21",
		Directories: []string{
			"cmd",
			"internal/application",
			"internal/domain",
			"internal/infrastructure",
			"internal/interfaces/http/handlers",
		},
		Files: []domain.ProjectFile{
			{
				Path: "go.mod",
				Type: "mod",
				Content: fmt.Sprintf(`module %s

go 1.21
`, moduleName),
				Template: false,
			},
			{
				Path: "cmd/main.go",
				Type: "go",
				Content: `package main

import (
	"log"
)

func main() {
	log.Println("Application starting...")
	// Add your application logic here
}
`,
				Template: false,
			},
			{
				Path:     "README.md",
				Type:     "md",
				Content:  fmt.Sprintf("# %s\n\nA Go application generated by the Go Factory Platform.\n\n## Getting Started\n\n```bash\ngo run cmd/main.go\n```\n\n## Build\n\n```bash\ngo build -o bin/app cmd/main.go\n```\n", moduleName),
				Template: false,
			},
		},
		Metadata: map[string]string{
			"created_by": "go-factory-platform",
			"version":    "1.0.0",
		},
		CreatedAt: time.Now(),
	}

	if err := s.CreateProject(ctx, structure); err != nil {
		return nil, fmt.Errorf("failed to create project structure: %w", err)
	}

	return structure, nil
}

// ProcessGeneratedFiles processes files from the generator service
func (s *CompilerApplicationService) ProcessGeneratedFiles(ctx context.Context, accumulator *domain.CodeAccumulator, projectPath string) (*domain.CompilationResult, error) {
	// Write files to filesystem
	if err := s.WriteFiles(ctx, accumulator, projectPath); err != nil {
		return nil, fmt.Errorf("failed to write files: %w", err)
	}

	// Validate code
	validationResult, err := s.ValidateCode(ctx, accumulator.Files)
	if err != nil {
		fmt.Printf("Warning: Code validation failed: %v\n", err)
		// Continue anyway
	} else if !validationResult.Valid {
		fmt.Printf("Warning: Code validation found issues: %d\n", len(validationResult.Issues))
		// Continue anyway
	}

	// Attempt compilation
	compilationResult, err := s.CompileProject(ctx, projectPath)
	if err != nil {
		return &domain.CompilationResult{
			ID:           fmt.Sprintf("comp_%d", time.Now().UnixNano()),
			ProjectPath:  projectPath,
			Success:      false,
			ErrorMessage: err.Error(),
			BuildTime:    0,
			Metadata:     make(map[string]string),
			CreatedAt:    time.Now(),
		}, nil
	}

	return compilationResult, nil
}
